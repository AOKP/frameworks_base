page.title=Предоставление ресурсов
parent.title=Ресурсы приложения
parent.link=index.html
@jd:body

<div id="qv-wrapper">
<div id="qv">
  <h2>Краткое описание</h2>
  <ul>
    <li>Разные типы ресурсов находятся в разных подкаталогах каталога {@code res/}</li>
    <li>Альтернативные ресурсы представляют собой файлы ресурсов для определенных конфигураций</li>
    <li>Обязательно включайте ресурсы по умолчанию, чтобы приложение не зависело от конфигураций конкретного
устройства</li>
  </ul>
  <h2>Содержание документа</h2>
  <ol>
    <li><a href="#ResourceTypes">Группирование типов ресурсов</a></li>
    <li><a href="#AlternativeResources">Предоставление альтернативных ресурсов</a>
      <ol>
        <li><a href="#QualifierRules">Правила квалификатора имени</a></li>
        <li><a href="#AliasResources">Создание псевдонимов ресурсов</a></li>
      </ol>
    </li>
    <li><a href="#Compatibility">Обеспечение оптимальной совместимости устройства с ресурсами</a></li>
    <li><a href="#BestMatch">Как Android находит наиболее подходящий ресурс</a></li>
  </ol>

  <h2>См. также:</h2>
  <ol>
    <li><a href="accessing-resources.html">Доступ к ресурсам</a></li>
    <li><a href="available-resources.html">Типы ресурсов</a></li>
    <li><a href="{@docRoot}guide/practices/screens_support.html">Поддержка
нескольких экранов</a></li>
  </ol>
</div>
</div>

<p>Обязательно необходимо экспортировать из кода ресурсы приложения, такие как изображения и строки,
для последующей их независимой обработки. Следует также обеспечить альтернативные ресурсы для
определенных конфигураций устройств, группируя их в каталогах ресурсов со специальными именами. В
режиме выполнения Android использует соответствующие ресурсы с учетом текущей конфигурации. Например,
можно предоставлять другой макет пользовательского интерфейса в зависимости от размера экрана или различные
строки в зависимости от настройки языка.</p>

<p>После выполнения экспорта ресурсов приложения можно обращаться к ним
с помощью идентификаторов ресурсов, которые генерируются в классе {@code R} вашего проекта. Использование
ресурсов в приложении рассмотрено в разделе <a href="accessing-resources.html">Доступ
к ресурсам</a>. В этом документе показано, как группировать ресурсы в проекте Android и
предоставлять альтернативные ресурсы для определенных конфигураций устройств.</p>


<h2 id="ResourceTypes">Группирование типов ресурсов</h2>

<p>Следует поместить ресурсы каждого типа в определенный подкаталог каталога
{@code res/} вашего проекта. В качестве примера приведена иерархия файлов для простого проекта:</p>

<pre class="classic no-pretty-print">
MyProject/
    src/  <span style="color:black">
        MyActivity.java  </span>
    res/
        drawable/  <span style="color:black">
            graphic.png  </span>
        layout/  <span style="color:black">
            main.xml
            info.xml</span>
        mipmap/  <span style="color:black">
            icon.png </span>
        values/  <span style="color:black">
            strings.xml  </span>
</pre>

<p>Как видно в этом примере, каталог {@code res/} содержит все ресурсы (в
подкаталогах): ресурс-изображение, два ресурса-макета, каталоги {@code mipmap/} для значков
запуска и файл строк. Имена каталогов
ресурсов очень важны и описаны в таблице 1.</p>

<p class="note"><strong>Примечание.</strong> Подробные сведения об использовании папок множественного отображения см. в разделе
<a href="{@docRoot}tools/projects/index.html#mipmap">Обзор управления проектами</a>.</p>

<p class="table-caption" id="table1"><strong>Таблица 1.</strong> Каталоги ресурсов,
поддерживаемые в каталоге {@code res/} проекта.</p>

<table>
  <tr>
    <th scope="col">Каталог</th>
    <th scope="col">Тип ресурсов</th>
  </tr>

  <tr>
    <td><code>animator/</code></td>
    <td>Файлы XML, которые определяют <a href="{@docRoot}guide/topics/graphics/prop-animation.html">анимации
свойств</a>.</td>
  </tr>

  <tr>
    <td><code>anim/</code></td>
    <td>Файлы XML, которые определяют <a href="{@docRoot}guide/topics/graphics/view-animation.html#tween-animation">анимации
преобразований</a>. (Анимации свойств также можно сохранять в этом каталоге, но
для анимаций свойств предпочтительнее использовать каталог {@code animator/}, чтобы различать эти два
типа).</td>
  </tr>

  <tr>
    <td><code>color/</code></td>
    <td>Файлы XML, которые определяют список состояний цветов. См. раздел <a href="color-list-resource.html">Ресурс списка
состояний цветов</a></td>
  </tr>

  <tr>
    <td><code>drawable/</code></td>

    <td><p>Файлы растровых изображений ({@code .png}, {@code .9.png}, {@code .jpg}, {@code .gif}) или файлы XML, которые
составляют следующие подтипы графических ресурсов:</p>
      <ul>
        <li>Файлы растровых изображений</li>
        <li>Файлы из девяти фрагментов (растровые изображения с возможностью изменения размера)</li>
        <li>Списки состояний</li>
        <li>Формы</li>
        <li>Графические анимации</li>
        <li>Другие графические элементы</li>
      </ul>
      <p>См. раздел <a href="drawable-resource.html">Графические ресурсы</a>.</p>
    </td>
  </tr>

  <tr>
    <td><code>mipmap/</code></td>
    <td>Графические файлы для значков запуска с различной плотностью. Подробные сведения об управлении
значками запуска с помощью папок {@code mipmap/} см. в разделе
 <a href="{@docRoot}tools/project/index.html#mipmap">Обзор управления проектами</a>.</td>
  </tr>

  <tr>
    <td><code>layout/</code></td>
    <td>Файлы XML, которые определяют макет пользовательского интерфейса.
        См. раздел <a href="layout-resource.html">Ресурсы макетов</a>.</td>
  </tr>

  <tr>
    <td><code>menu/</code></td>
    <td>Файлы XML, которые определяют меню приложения, такие как меню параметров, контекстные меню или вложенные
меню. См. раздел <a href="menu-resource.html">Ресурсы меню</a>.</td>
  </tr>

  <tr>
    <td><code>raw/</code></td>
    <td><p>Произвольные файлы для сохранения в исходной форме. Чтобы открыть эти ресурсы с помощью
{@link java.io.InputStream}, вызовите {@link android.content.res.Resources#openRawResource(int)
Resources.openRawResource()} с идентификатором ресурса, который имеет вид {@code R.raw.<em>filename</em>}.</p>
      <p>Однако, если требуется получить доступ к исходным именам файлов и иерархии файлов, можно
сохранять некоторые ресурсы в каталоге {@code
assets/} (вместо каталога {@code res/raw/}). Файлы в каталоге {@code assets/} не получают
идентификатора ресурса, поэтому их чтение возможно только с помощью {@link android.content.res.AssetManager}.</p></td>
  </tr>

  <tr>
    <td><code>values/</code></td>
    <td><p>Файлы XML, которые содержат простые значения, такие как строки, целые числа и цвета.</p>
      <p>Тогда как XML-файлы ресурсов в других подкаталогах каталога {@code res/} определяют отдельные ресурсы
на базе имени файла XML, файлы в каталоге {@code values/} описывают несколько ресурсов.
Для файла в этом каталоге каждый дочерний элемент элемента {@code &lt;resources&gt;} определяет один
ресурс. Например, элемент {@code &lt;string&gt;} создает ресурс
{@code R.string}, а элемент {@code &lt;color&gt;} создает ресурс {@code R.color}
.</p>
      <p>Так как каждый ресурс определяется с помощью своего собственного элемента XML, можно назначать имя файла
по своему усмотрению и помещать ресурсы разных типов в один файл. Тем не мене, может
появиться необходимость поместить ресурсы отдельных типов в разные файлы. Например, ниже приведены соглашения для имен файлов
ресурсов, которые можно создать в этом каталоге:</p>
      <ul>
        <li>arrays.xml для ресурсов-массивов (<a href="more-resources.html#TypedArray">массивы с указанием типа</a>)</li>
        <li>colors.xml для <a href="more-resources.html#Color">значений цветов</a></li>
        <li>dimens.xml для <a href="more-resources.html#Dimension">значений единиц измерений</a></li>
        <li>strings.xml для <a href="string-resource.html">строковых
значений</a></li>
        <li>styles.xml для <a href="style-resource.html">стилей</a>.</li>
      </ul>
      <p>См. разделы <a href="string-resource.html">Строковые ресурсы</a>,
        <a href="style-resource.html">Ресурсы стиля</a> и
 <a href="more-resources.html">Дополнительные типы ресурсов</a>.</p>
    </td>
  </tr>

  <tr>
    <td><code>xml/</code></td>
    <td>Произвольные XML-файлы, которые можно читать в режиме выполнения вызовом метода {@link
android.content.res.Resources#getXml(int) Resources.getXML()}. Здесь должны сохраняться различные файлы конфигурации XML,
например, <a href="{@docRoot}guide/topics/search/searchable-config.html">конфигурация с возможностью поиска</a>.
<!-- or preferences configuration. --></td>
  </tr>
</table>

<p class="caution"><strong>Предупреждение!</strong> Не сохраняйте файлы ресурсов непосредственно в
каталоге {@code res/}, так как это вызывает ошибку компилятора.</p>

<p>Дополнительную информацию об определенных типах ресурсов см. в документации <a href="available-resources.html">Типы ресурсов</a>.</p>

<p>Ресурсы, сохраненные в подкаталогах, которые описаны в таблице 1, являются ресурсами
«по умолчанию». Таким образом, эти ресурсы определяют дизайн и содержимое приложения по умолчанию.
Однако различные типы устройств Android могут вызывать различные типы ресурсов.
Например, если устройство оснащено экраном больше нормального, следует предоставить
другие ресурсы макета, которые будут использовать преимущества дополнительного места на экране. Или, если устройство
содержит различные языковые настройки, следует предоставить другие строковые ресурсы, содержащие перевод
текста пользовательского интерфейса. Чтобы предоставить разные ресурсы для разных конфигураций устройств,
необходимо предоставить альтернативные ресурсы в дополнение к ресурсам
по умолчанию.</p>


<h2 id="AlternativeResources">Предоставление альтернативных ресурсов</h2>


<div class="figure" style="width:429px">
<img src="{@docRoot}images/resources/resource_devices_diagram2.png" height="167" alt="" />
<p class="img-caption">
<strong>Рисунок 1.</strong> Два разных устройства, которые используют разные ресурсы макета.</p>
</div>

<p>Почти каждое приложение должно предоставлять альтернативные ресурсы, чтобы поддерживать определенные конфигурации
устройств. Например, необходимо включить альтернативные графические ресурсы для экранов с
разной плотностью растра и альтернативные ресурсы для разных языков. В режиме выполнения Android
определяет конфигурацию устройства и загружает соответствующие
ресурсы для приложения.</p>

<p>Чтобы указать альтернативы для конкретных конфигураций набора ресурсов, выполните следующие действия:</p>
<ol>
  <li>Создайте новый каталог в каталоге {@code res/} с именем следующего вида {@code
<em>&lt;имя_ресурса&gt;</em>-<em>&lt;квалификатор_конфигурации&gt;</em>}.
    <ul>
      <li><em>{@code &lt;resources_name&gt;}</em> – имя каталога соответствующих ресурсов
по умолчанию (определено в таблице 1).</li>
      <li><em>{@code &lt;qualifier&gt;}</em> – имя, которое указывает определенную конфигурацию,
для которой должны использоваться эти ресурсы (определено в таблице 2).</li>
    </ul>
    <p>Можно добавлять несколько квалификаторов <em>{@code &lt;qualifier&gt;}</em>. Разделяйте их
знаком дефиса.</p>
    <p class="caution"><strong>Предупреждение!</strong> При добавлении нескольких квалификаторов необходимо
располагать их в том же порядке, в котором они перечислены в таблице 2. Если порядок квалификаторов нарушен,
 ресурсы игнорируются.</p>
  </li>
  <li>Сохраните соответствующие альтернативные ресурсы в этом новом каталоге. Файлы ресурсов должны
иметь имена, точно совпадающие с именами файлов ресурсов по умолчанию.</li>
</ol>

<p>В качестве примера здесь приведено несколько ресурсов по умолчанию и альтернативных ресурсов:</p>

<pre class="classic no-pretty-print">
res/
    drawable/   <span style="color:black">
        icon.png
        background.png    </span>
    drawable-hdpi/  <span style="color:black">
        icon.png
        background.png  </span>
</pre>

<p>Квалификатор {@code hdpi} указывает, что ресурсы в этом каталоге предназначены для устройств, оснащенных экраном
высокой плотности. Изображения в каждом из этих каталогов для графических объектов имеют размер для определенной плотности
экрана, но имена файлов полностью
совпадают. Таким образом, идентификатор ресурса, который указывает на изображение {@code icon.png} или {@code
background.png}, всегда одинаков, но Android выбирает
версию каждого ресурса, которая оптимально соответствует текущему устройству, сравнивая информацию о конфигурации устройства
с квалификаторами в имени каталога ресурсов.</p>

<p>Android поддерживает несколько квалификаторов конфигурации, позволяя
добавлять несколько квалификаторов к одному имени каталога, разделяя квалификаторы дефисом. В таблице 2
перечислены допустимые квалификаторы конфигурации в порядке приоритета &mdash; если используется несколько
квалификаторов для каталога ресурсов, необходимо добавлять их к имени каталога в том порядке, в котором
они перечислены в таблице.</p>


<p class="table-caption" id="table2"><strong>Таблица 2.</strong> Имена квалификаторов
конфигурации.</p>
<table>
    <tr>
        <th>Конфигурация</th>
        <th>Значения квалификатора</th>
        <th>Описание</th>
    </tr>
    <tr id="MccQualifier">
      <td>MCC и MNC</td>
      <td>Примеры:<br/>
        <code>mcc310</code><br/>
        <code><nobr>mcc310-mnc004</nobr></code><br/>
        <code>mcc208-mnc00</code><br/>
        и т. д.
      </td>
      <td>
        <p>Код страны для мобильной связи (MCC), за которым может следовать код сети мобильной связи (MNC)
 из SIM-карты устройства. Например, <code>mcc310</code> – код США для любого поставщика услуг,
 <code>mcc310-mnc004</code> – код США для Verizon и <code>mcc208-mnc00</code> – код Франции
 для Orange.</p>
        <p>Если в устройстве используется радиосвязь (телефон GSM), значения MCC и MNC добываются
 из SIM-карты.</p>
        <p>Можно также использовать только код MCC (например, для включения в приложении разрешенных в стране
ресурсов). Если требуется указать только язык, используйте квалификатор
<em>язык и регион</em> (обсуждается ниже). Если принято решение использовать квалификатор MCC и
MNC, следует делать это с осторожностью и проверить корректность его работы.</p>
        <p>См. также поля конфигурации {@link
android.content.res.Configuration#mcc} и {@link
android.content.res.Configuration#mnc}, которые указывают текущий код страны при мобильной связи
и код сети мобильной связи соответственно.</p>
      </td>
    </tr>
    <tr id="LocaleQualifier">
      <td>Язык и регион</td>
      <td>Примеры:<br/>
        <code>en</code><br/>
        <code>fr</code><br/>
        <code>en-rUS</code><br/>
        <code>fr-rFR</code><br/>
        <code>fr-rCA</code><br/>
        и т. д.
      </td>
      <td><p>Язык задается двухбуквенным кодом языка <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO
 639-1</a>, к которому можно добавить двухбуквенный код региона
 <a href="http://www.iso.org/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html">ISO
 3166-1-alpha-2</a> (которому предшествует строчная буква "{@code r}").
        </p><p>
        Коды <em>не</em> зависят от регистра; префикс {@code r} служит для
обозначения кода региона.
        Нельзя указывать только код региона.</p>
        <p>Он может измениться за время работы
приложения, если пользователь изменяет свой язык в системных настройках. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится информация
о воздействии таких изменений на приложение во время выполнения.</p>
        <p>В разделе <a href="localization.html">Локализация</a> приведено полное руководство по локализации
приложения для других языков.</p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#locale}, которое
указывает текущий язык.</p>
      </td>
    </tr>
    <tr id="LayoutDirectionQualifier">
      <td>Направление макета</td>
      <td><code>ldrtl</code><br/>
        <code>ldltr</code><br/>
      </td>
      <td><p>Направление макета для приложения. Квалификатор {@code ldrtl} означает «направление макета справа налево».
Квалификатор {@code ldltr} означает «направление макета слева направо» и используется по умолчанию.
      </p>
      <p>Эти квалификаторы можно применять к любым ресурсам, таким как макеты, графические элементы или значения.
      </p>
      <p>Например, если требуется предоставить специальный макет для арабского языка и
общий макет для других языков, использующих написание «справа налево» (таких как фарси или иврит), используйте следующий код:
      </p>
<pre class="classic no-pretty-print">
res/
    layout/   <span style="color:black">
        main.xml  </span>(Default layout)
    layout-ar/  <span style="color:black">
        main.xml  </span>(Specific layout for Arabic)
    layout-ldrtl/  <span style="color:black">
        main.xml  </span>(Any "right-to-left" language, except
                  for Arabic, because the "ar" language qualifier
                  has a higher precedence.)
</pre>
        <p class="note"><strong>Примечание.</strong> Чтобы включить в приложение функцию макета «справа налево»,
необходимо установить для параметра <a href="{@docRoot}guide/topics/manifest/application-element.html#supportsrtl">{@code
        supportsRtl}</a> значение {@code "true"} и для параметра <a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#target">{@code targetSdkVersion}</a> значение 17 или больше.</p>
        <p><em>Добавлено в API уровня 17.</em></p>
      </td>
    </tr>
    <tr id="SmallestScreenWidthQualifier">
      <td>smallestWidth</td>
      <td><code>sw&lt;N&gt;dp</code><br/><br/>
        Примеры:<br/>
        <code>sw320dp</code><br/>
        <code>sw600dp</code><br/>
        <code>sw720dp</code><br/>
        и т. д.
      </td>
      <td>
        <p>Основной размер экрана, указывающий минимальный размер доступной
области экрана. Точнее говоря, минимальная ширина устройства – это наименьший из двух размеров экрана:
высоты и ширины (можно также называть ее «меньшей стороной» экрана). Этот квалификатор
позволяет гарантировать, что независимо от текущей ориентации экрана
приложение имеет доступную ширину пользовательского интерфейса не менее {@code &lt;N&gt;} пикселов.</p>
        <p>Например, если для макета требуется, чтобы минимальный размер области экрана всегда был
не менее 600 пикселов, можно использовать этот квалификатор для создания ресурсов этого макета, {@code
res/layout-sw600dp/}. Система будет использовать эти ресурсы только в том случае, если минимальный размер
доступной области экрана составляет не менее 600 пикселов, независимо от воспринимаемой пользователем
высоты или ширины. Значение минимальной ширины является постоянной характеристикой размера экрана для устройства; <strong>минимальная
ширина устройства не изменяется при изменении ориентации экрана</strong>.</p>
        <p>Минимальная ширина устройства учитывает оформление экрана и пользовательский интерфейс системы. Например,
если не экране присутствуют постоянные элементы пользовательского интерфейса, которые занимают пространство вдоль
оси минимальной ширины, система объявляет, что минимальная ширина меньше фактического
размера экрана, так как эти пикселы экрана недоступны для пользовательского интерфейса приложения. Следовательно используемое значение
должно быть фактическим наименьшим размером, <em>который необходим для вашего макета</em> (обычно это значение является
«минимальной шириной», которую поддерживает ваш макет, независимо от текущей ориентации экрана).</p>
        <p>Здесь приведены некоторые значения, которые можно использовать для экранов обычных размеров:</p>
        <ul>
          <li>320 для устройств с конфигурациями экрана:
            <ul>
              <li>240x320 ldpi (смартфон QVGA)</li>
              <li>320x480 mdpi (смартфон)</li>
              <li>480x800 hdpi (смартфон высокой плотности)</li>
            </ul>
          </li>
          <li>480 для таких экранов, как 480x800 mdpi (планшет/смартфон).</li>
          <li>600 для таких экранов, как 600x1024 mdpi (планшет с диагональю 7").</li>
          <li>720 для таких экранов, как 720x1280 mdpi (планшет с диагональю 10").</li>
        </ul>
        <p>Когда приложение предоставляет несколько каталогов ресурсов с разными значениями
квалификатора «минимальная ширина», система использует квалификатор, ближайший
к минимальной ширине устройства, но не превышающий ее. </p>
        <p><em>Добавлено в API уровня 13.</em></p>
        <p>См. также атрибут <a href="{@docRoot}guide/topics/manifest/supports-screens-element.html#requiresSmallest">{@code
android:requiresSmallestWidthDp}</a>, который объявляет минимальную ширину, совместимую
с вашим приложением, и поле конфигурации {@link
android.content.res.Configuration#smallestScreenWidthDp}, которое содержит значение
минимальной ширины устройства.</p>
        <p>Дополнительную информацию о разработке для различных экранов и использовании этого
квалификатора см. в руководстве разработчика <a href="{@docRoot}guide/practices/screens_support.html">Поддержка
нескольких экранов</a>.</p>
      </td>
    </tr>
    <tr id="ScreenWidthQualifier">
      <td>Доступная ширина</td>
      <td><code>w&lt;N&gt;dp</code><br/><br/>
        Примеры:<br/>
        <code>w720dp</code><br/>
        <code>w1024dp</code><br/>
        и т. д.
      </td>
      <td>
        <p>Указывает минимальную доступную ширину экрана в единицах {@code dp}, для которой должен использоваться ресурс,
заданный значением <code>&lt;N&gt;</code>.  Это
значение конфигурации будет изменяться в соответствии с текущей фактической шириной
при изменении альбомной/книжной ориентации.</p>
        <p>Когда приложение предоставляет несколько каталогов ресурсов с разными значениями
этой конфигурации, система использует ширину, ближайшую к текущей
ширине экрана устройства, но не превышающую ее.  Это значение
учитывает оформление экрана, поэтому, если устройство содержит
постоянные элементы пользовательского интерфейса вдоль левого или правого края дисплея, оно
использует значение ширины, которое меньше реального размера экрана: эти элементы
пользовательского интерфейса учитываются и уменьшают пространство, доступное для приложения.</p>
        <p><em>Добавлено в API уровня 13.</em></p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#screenWidthDp}
, которое содержит текущую ширину экрана.</p>
        <p>Дополнительную информацию о разработке для различных экранов и использовании этого
квалификатора см. в руководстве разработчика <a href="{@docRoot}guide/practices/screens_support.html">Поддержка
нескольких экранов</a>.</p>
      </td>
    </tr>
    <tr id="ScreenHeightQualifier">
      <td>Доступная высота</td>
      <td><code>h&lt;N&gt;dp</code><br/><br/>
        Примеры:<br/>
        <code>h720dp</code><br/>
        <code>h1024dp</code><br/>
        и т. д.
      </td>
      <td>
        <p>Указывает минимальную доступную высоту экрана в пикселах, для которой должен использоваться ресурс,
заданный значением <code>&lt;N&gt;</code>.  Это
значение конфигурации будет изменяться в соответствии с текущей фактической высотой
при изменении альбомной/книжной ориентации.</p>
        <p>Когда приложение предоставляет несколько каталогов ресурсов с разными значениями
этой конфигурации, система использует высоту, ближайшую к текущей
высоте экрана устройства, но не превышающую ее.  Это значение
учитывает оформление экрана, поэтому, если устройство содержит
постоянные элементы пользовательского интерфейса вдоль верхнего или нижнего края дисплея, оно
использует значение высоты, которое меньше реального размера экрана: эти элементы
пользовательского интерфейса учитываются и уменьшают пространство, доступное для приложения.  Элементы оформления
экрана, которые не являются постоянными (например, строка состояния телефона может быть
скрыта в полноэкранном режиме), здесь <em>не</em> учитываются; также не учитываются такие элементы
оформления окна, как строка заголовка или строка действий, поэтому приложения должны быть готовы к работе с меньшим
пространством, чем указано.
        <p><em>Добавлено в API уровня 13.</em></p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#screenHeightDp}
, которое содержит текущую ширину экрана.</p>
        <p>Дополнительную информацию о разработке для различных экранов и использовании этого
квалификатора см. в руководстве разработчика <a href="{@docRoot}guide/practices/screens_support.html">Поддержка
нескольких экранов</a>.</p>
      </td>
    </tr>
    <tr id="ScreenSizeQualifier">
      <td>Размер экрана</td>
      <td>
        <code>small</code><br/>
        <code>normal</code><br/>
        <code>large</code><br/>
        <code>xlarge</code>
      </td>
      <td>
        <ul class="nolist">
        <li>{@code small}: Экраны, подобные по размеру
экрану QVGA низкой плотности. Минимальный размер макета для маленького экрана
составляет приблизительно 320x426 пикселов.  Примерами являются экраны QVGA низкой плотности и VGA высокой
плотности.</li>
        <li>{@code normal}: Экраны, подобные по размеру
экрану HVGA средней плотности. Минимальный
размер макета для нормального экрана составляет приблизительно 320x470 пикселов.  Примерами таких экранов
являются экраны WQVGA низкой плотности, HVGA средней плотности, WVGA
высокой плотности.</li>
        <li>{@code large}: Экраны, подобные по размеру
экрану VGA средней плотности.
        Минимальный размер макета для большого экрана составляет приблизительно 480x640 пикселов.
        Примерами являются экраны VGA и WVGA средней плотности.</li>
        <li>{@code xlarge}: Экраны значительно крупнее обычного
экрана HVGA средней плотности. Минимальный размер макета для очень большого экрана составляет
приблизительно 720x960 пикселов.  В большинстве случаев устройства с очень большими
экранами слишком велики для карманного использования и, скорее всего,
относятся к планшетам. <em>Добавлено в API уровня 9.</em></li>
        </ul>
        <p class="note"><strong>Примечание.</strong> Использование квалификатора размера не подразумевает, что
ресурсы предназначены <em>только</em> для экранов этого размера. Если не предусмотрены
альтернативные ресурсы с квалификаторами, лучше подходящими к текущей конфигурации устройства, система может использовать
любые <a href="#BestMatch">наиболее подходящие</a> ресурсы.</p>
        <p class="caution"><strong>Предупреждение!</strong> Если все ресурсы используют квалификатор размера,
который <em>превосходит</em> размер текущего экрана, система <strong>не</strong> будет использовать эти ресурсы, и приложение
аварийно завершится во время выполнения (например, если все ресурсы макета отмечены квалификатором {@code
xlarge}, но устройство оснащено экраном нормального размера).</p>
        <p><em>Добавлено в API уровня 4.</em></p>

        <p>Дополнительную информацию см. в разделе <a href="{@docRoot}guide/practices/screens_support.html">Поддержка нескольких
экранов</a>.</p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#screenLayout}, которое
указывает тип размера экрана: маленький, нормальный
или большой.</p>
      </td>
    </tr>
    <tr id="ScreenAspectQualifier">
      <td>Формат экрана</td>
      <td>
        <code>long</code><br/>
        <code>notlong</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code long}: Длинные экраны, такие как WQVGA, WVGA, FWVGA</li>
          <li>{@code notlong}: Недлинные экраны, такие как QVGA, HVGA и VGA</li>
        </ul>
        <p><em>Добавлено в API уровня 4.</em></p>
        <p>Формат основан исключительно на соотношении сторон экрана («длинный» экран шире). Это
не связано с ориентацией экрана.</p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#screenLayout}, которое
указывает, является ли экран длинным.</p>
      </td>
    </tr>
    <tr id="OrientationQualifier">
      <td>Ориентация экрана</td>
      <td>
        <code>port</code><br/>
        <code>land</code>  <!-- <br/>
        <code>square</code>  -->
      </td>
      <td>
        <ul class="nolist">
          <li>{@code port}: Устройство в портретной (вертикальной) ориентации</li>
          <li>{@code land}: Устройство в книжной (горизонтальной) ориентации</li>
          <!-- Square mode is currently not used. -->
        </ul>
        <p>Ориентация может измениться за время работы приложения, если
пользователь поворачивает экран. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится информация
о воздействии таких изменений на приложение во время выполнения.</p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#orientation}, которое
указывает текущую ориентацию устройства.</p>
      </td>
    </tr>
    <tr id="UiModeQualifier">
      <td>Режим пользовательского интерфейса</td>
      <td>
        <code>car</code><br/>
        <code>desk</code><br/>
        <code>television</code><br/>
        <code>appliance</code>
        <code>watch</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code car}: Устройство подсоединено к автомобильной док-станции</li>
          <li>{@code desk}: Устройство подсоединено к настольной док-станции</li>
          <li>{@code television}: Устройство подсоединено к телевизору, обеспечивая
взаимодействие с расстояния «три метра», когда пользовательский интерфейс находится на большом экране,
находящемся вдалеке от пользователя, ориентированное на управление с помощью навигационной клавиши или другого
устройства без указателя</li>
          <li>{@code appliance}: Устройство служит в качестве прибора без
дисплея</li>
          <li>{@code watch}: Устройство с дисплеем для ношения на запястье</li>
        </ul>
        <p><em>Добавлено в API уровня 8, телевизор добавлен в API 13, часы добавлены в API 20.</em></p>
        <p>Информацию о том, как приложение может реагировать на установку устройства в
док-станцию или извлечение из нее, прочитайте документ <a href="{@docRoot}training/monitoring-device-state/docking-monitoring.html">Определение
и мониторинг типа и состояния подключения к док-станции</a>.</p>
        <p>Подключение может измениться за время работы приложения, если пользователь помещает устройство
в док-станцию. Некоторые из этих режимов можно включить или отключить с помощью {@link
android.app.UiModeManager}. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится
информация о воздействии таких изменений на приложение во время выполнения.</p>
      </td>
    </tr>
    <tr id="NightQualifier">
      <td>Ночной режим</td>
      <td>
        <code>night</code><br/>
        <code>notnight</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code night}: Ночное время</li>
          <li>{@code notnight}: Дневное время</li>
        </ul>
        <p><em>Добавлено в API уровня 8.</em></p>
        <p>Этот режим может измениться за время работы, если ночной режим оставлен в
автоматическом режиме (по умолчанию), в котором режим изменяется в зависимости от времени суток.  Этот режим можно включить
или отключить с помощью {@link android.app.UiModeManager}. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится информация о воздействии таких
изменений на приложение во время выполнения.</p>
      </td>
    </tr>
    <tr id="DensityQualifier">
      <td>Плотность пикселов на экране (dpi)</td>
      <td>
        <code>ldpi</code><br/>
        <code>mdpi</code><br/>
        <code>hdpi</code><br/>
        <code>xhdpi</code><br/>
        <code>xxhdpi</code><br/>
        <code>xxxhdpi</code><br/>
        <code>nodpi</code><br/>
        <code>tvdpi</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code ldpi}: Экраны низкой плотности; приблизительно 120 dpi.</li>
          <li>{@code mdpi}: Экраны средней плотности (обычные HVGA); приблизительно
160 dpi.</li>
          <li>{@code hdpi}: Экраны высокой плотности; приблизительно 240 dpi.</li>
          <li>{@code xhdpi}: Экраны очень высокой плотности; приблизительно 320 dpi. <em>Добавлено в API
уровня 8.</em></li>
          <li>{@code xxhdpi}: Экраны сверхвысокой плотности; приблизительно 480 dpi. <em>Добавлено в API
уровня 16.</em></li>
          <li>{@code xxxhdpi}: Использование исключительно высокой плотности (только значок запуска, см.
<a href="{@docRoot}guide/practices/screens_support.html#xxxhdpi-note">примечание</a>
в документе <em>Поддержка нескольких экранов</em>); приблизительно 640 dpi. <em>Добавлено в API
уровня 18.</em></li>
          <li>{@code nodpi}: Этот режим можно использовать для растровых графических ресурсов, которые не требуется масштабировать
в соответствии с плотностью устройства.</li>
          <li>{@code tvdpi}: Экраны промежуточной плотности между mdpi и hdpi; приблизительно 213 dpi. Этот режим не считается
«основной» группой плотности. Он главным образом предназначен для телевизоров, и большинство
приложений в нем не нуждается &mdash; при условии, что ресурсов mdpi и hdpi достаточно для большинства приложений, и
система будет масштабировать их при необходимости. Этот квалификатор введен в API уровня 13.</li>
        </ul>
        <p>Шесть основных уровней плотности соотносятся как 3:4:6:8:12:16 (если игнорировать
плотность tvdpi). Так, растровое изображение 9x9 в ldpi представляется как 12x12 в mdpi, 18x18 в hdpi, 24x24 в xhdpi и т. д.
</p>
        <p>Если графические ресурсы выглядят недостаточно хорошо на телевизоре или
других определенных устройствах, и хочется попробовать ресурсы tvdpi, используйте масштабный коэффициент 1,33*mdpi. Например,
 изображение 100 x 100 пикселов для экранов mdpi должно иметь размер 133 x 133 пиксела для tvdpi.</p>
        <p class="note"><strong>Примечание.</strong> Использование квалификатора плотности не подразумевает, что
ресурсы предназначены <em>только</em> для экранов этой плотности. Если не предусмотрены
альтернативные ресурсы с квалификаторами, лучше подходящими к текущей конфигурации устройства, система может использовать
любые <a href="#BestMatch">наиболее подходящие</a> ресурсы.</p>
        <p>Дополнительную информацию о том, как обрабатывать
различные плотности экранов, и как Android может масштабировать растровые изображения в соответствии текущей плотностью, см. в разделе <a href="{@docRoot}guide/practices/screens_support.html">Поддержка нескольких
экранов</a>.</p>
       </td>
    </tr>
    <tr id="TouchscreenQualifier">
      <td>Тип сенсорного экрана</td>
      <td>
        <code>notouch</code><br/>
        <code>finger</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code notouch}: Устройство не оснащено сенсорным экраном.</li>
          <li>{@code finger}: Устройство оснащено сенсорным экраном, предназначенным
для ввода с помощью пальцев пользователя.</li>
        </ul>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#touchscreen}, которое
указывает тип сенсорного экрана устройства.</p>
      </td>
    </tr>
    <tr id="KeyboardAvailQualifier">
      <td>Доступность клавиатуры</td>
      <td>
        <code>keysexposed</code><br/>
        <code>keyshidden</code><br/>
        <code>keyssoft</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code keysexposed}: В устройстве доступна клавиатура. Если в устройстве включена
экранная клавиатура (что весьма вероятно), она может использоваться даже в случае, когда аппаратная клавиатура
<em></em> недоступна пользователю, даже если устройство не имеет аппаратной клавиатуры. Если экранная
клавиатура отсутствует или отключена, это квалификатор используется только в том случае, когда доступна
аппаратная клавиатура.</li>
          <li>{@code keyshidden}: Устройство имеет аппаратную клавиатуру, но она
скрыта, <em>и </em> в устройстве <em>не</em> включена экранная клавиатура.</li>
          <li>{@code keyssoft}: Экранная клавиатура в устройстве включена независимо от того,
видна она или нет.</li>
        </ul>
        <p>Если предоставляются ресурсы <code>keysexposed</code>, но не предоставляются ресурсы <code>keyssoft</code>,
система использует ресурсы <code>keysexposed</code> независимо от видимости
клавиатуры, поскольку в системе включена экранная клавиатура.</p>
        <p>Это состояние может измениться за время работы приложения, если
пользователь открывает аппаратную клавиатуру. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится информация о воздействии таких
изменений на приложение во время выполнения.</p>
        <p>См. также поля конфигурации {@link
android.content.res.Configuration#hardKeyboardHidden} и {@link
android.content.res.Configuration#keyboardHidden}, которые указывают видимость аппаратной
клавиатуры и видимость клавиатуры любого типа (включая экранную), соответственно.</p>
      </td>
    </tr>
    <tr id="ImeQualifier">
      <td>Основной способ ввода текста</td>
      <td>
        <code>nokeys</code><br/>
        <code>qwerty</code><br/>
        <code>12key</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code nokeys}: В устройстве отсутствуют аппаратные клавиши для ввода текста.</li>
          <li>{@code qwerty}: Устройство оснащено аппаратной клавиатурой с раскладкой qwerty, независимо от того, видна она
пользователю
или нет.</li>
          <li>{@code 12key}: Устройство оснащено аппаратной клавиатурой с 12 клавишами, независимо от того, видна она пользователю
или нет.</li>
        </ul>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#keyboard}, которое
указывает основной доступный способ ввода текста.</p>
      </td>
    </tr>
    <tr id="NavAvailQualifier">
      <td>Доступность клавиш перемещения</td>
      <td>
        <code>navexposed</code><br/>
        <code>navhidden</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code navexposed}: Клавиши перемещения доступны пользователю.</li>
          <li>{@code navhidden}: Клавиши перемещения недоступны (например, находятся за
закрытой крышкой).</li>
        </ul>
        <p>Это состояние может измениться за время работы приложения, если
пользователь открывает клавиши перемещения. В разделе <a href="runtime-changes.html">Обработка изменений в режиме выполнения</a> содержится
информация о воздействии таких изменений на приложение во время выполнения.</p>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#navigationHidden}, которое
указывает, скрыты ли клавиши перемещения.</p>
      </td>
    </tr>
    <tr id="NavigationQualifier">
      <td>Основной несенсорный способ перемещения курсора</td>
      <td>
        <code>nonav</code><br/>
        <code>dpad</code><br/>
        <code>trackball</code><br/>
        <code>wheel</code>
      </td>
      <td>
        <ul class="nolist">
          <li>{@code nonav}: Устройство не оснащено другими средствами перемещения курсора, кроме
сенсорного экрана.</li>
          <li>{@code dpad}: Устройство оснащено навигационной клавишей.</li>
          <li>{@code trackball}: Устройство оснащено трекболом.</li>
          <li>{@code wheel}: Устройство оснащено навигационным колесиком (редко).</li>
        </ul>
        <p>См. также поле конфигурации {@link android.content.res.Configuration#navigation}, которое
указывает способ перемещения курсора.</p>
      </td>
    </tr>
<!-- DEPRECATED
    <tr>
      <td>Screen dimensions</td>
      <td>Examples:<br/>
        <code>320x240</code><br/>
        <code>640x480</code><br/>
        etc.
      </td>
      <td>
        <p>The larger dimension must be specified first. <strong>This configuration is deprecated
and should not be used</strong>. Instead use "screen size," "wider/taller screens," and "screen
orientation" described above.</p>
      </td>
    </tr>
-->
    <tr id="VersionQualifier">
      <td>Версия платформы (уровень API)</td>
      <td>Примеры:<br/>
        <code>v3</code><br/>
        <code>v4</code><br/>
        <code>v7</code><br/>
        и т. д.</td>
      <td>
        <p>Уровень API, поддерживаемый устройством. Например, <code>v1</code> для уровня API
1 (устройства с Android 1.0 или выше) и <code>v4</code> для уровня API 4 (устройства с Android
1.6 или выше). В документе <a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#ApiLevels">Уровни API Android</a> содержится дополнительная информация
об этих значениях.</p>
      </td>
    </tr>
</table>


<p class="note"><strong>Примечание.</strong> Некоторые квалификаторы конфигурации добавлены после версии Android
1.0, поэтому в некоторых версиях Android поддерживаются не все квалификаторы. При использовании нового квалификатора косвенно
добавляется квалификатор версии платформы, чтобы более старые устройства игнорировали его. Например, при использовании
квалификатора <code>w600dp</code> автоматически добавляется квалификатор <code>v13</code>, так как квалификатор
доступной ширины был новым в API уровня 13. Чтобы исключить какие-либо проблемы, всегда включайте набор
ресурсов по умолчанию (набор ресурсов <em>без квалификаторов</em>). Для получения дополнительной информации см.
раздел <a href="#Compatibility">Обеспечение оптимальной совместимости устройства с
ресурсами</a>.</p>



<h3 id="QualifierRules">Правила квалификатора имени</h3>

<p>Здесь приведены некоторые правила использования имен квалификаторов:</p>

<ul>
    <li>Можно указать несколько квалификаторов для одного набора ресурсов, разделяя их дефисами. Например,
 <code>drawable-en-rUS-land</code> применяется к устройствам в США, на английском языке в альбомной
ориентации.</li>
    <li>Квалификаторы должны идти в том же порядке, в котором они перечислены в <a href="#table2">таблице 2</a>. Например:

      <ul>
        <li>Неправильно: <code>drawable-hdpi-port/</code></li>
        <li>Правильно: <code>drawable-port-hdpi/</code></li>
      </ul>
    </li>
    <li>Нельзя использовать вложенные каталоги альтернативных ресурсов. Например, нельзя иметь каталог
<code>res/drawable/drawable-en/</code>.</li>
    <li>Значения не зависят от регистра букв.  Компилятор ресурсов преобразует имена каталогов
в нижний регистр перед обработкой, чтобы избежать проблем в файловых системах,
не учитывающих регистр. Прописные буквы в именах служат исключительно для удобочитаемости.</li>
    <li>Поддерживается только одно значение квалификатора каждого типа. Например, если требуется использовать
одинаковые графические файлы для испанского и французского языков, <em>нельзя</em> создавать
каталог с именем <code>drawable-rES-rFR/</code>. Вместо этого необходимо создать два каталога ресурсов, например,
<code>drawable-rES/</code> и <code>drawable-rFR/</code>, которые содержат соответствующие файлы.
Однако не обязательно фактически копировать одинаковые файлы в оба каталога. Вместо этого
можно создать псевдоним для ресурса. См. раздел <a href="#AliasResources">Создание
псевдонимов ресурсов</a> ниже.</li>
</ul>

<p>После сохранения альтернативных ресурсов в каталоги с именами
этих квалификаторов Android автоматически применяет ресурсы в приложении на основе текущей конфигурации
устройства. При каждом запросе ресурсов Android проверяет каталоги альтернативных
ресурсов, которые содержат файл запрошенного ресурса, затем <a href="#BestMatch">находят
наиболее подходящий ресурс</a> (обсуждается ниже). Если нет альтернативных ресурсов, которые
соответствуют конкретной конфигурации устройства, Android использует ресурсы по умолчанию (набор
ресурсов для конкретного типа ресурсов, которые не содержат квалификатора
конфигурации).</p>



<h3 id="AliasResources">Создание псевдонимов ресурсов</h3>

<p>Ресурс, предназначенный для нескольких конфигураций
устройства (но не являющийся ресурсом по умолчанию), следует помещать
только в один каталог альтернативных ресурсов. Вместо этого можно (в некоторых случаях) создать
альтернативный
ресурс, действующий в качестве псевдонима для ресурса, сохраненного в каталоге ресурсов по умолчанию.</p>

<p class="note"><strong>Примечание.</strong> Не все ресурсы предлагают механизм, позволяющий
создавать псевдоним для другого ресурса. В частности, анимации, меню, необработанные и другие неустановленные
ресурсы в каталоге {@code xml/} не содержат такой возможности.</p>

<p>Например, представьте, что имеется значок приложения, {@code icon.png}, и требуется иметь уникальные версии
этого значка для разных языков. Однако в двух языках, канадском английском и канадском французском, требуется
использовать одинаковую версию. Можно предположить, что требуется скопировать одно изображение
в каталоги ресурсов для обоих языков, но
это неверно. Вместо этого можно сохранить изображение для обоих языков, как {@code icon_ca.png} (любое
имя, кроме {@code icon.png}), и поместить его
в каталог по умолчанию {@code res/drawable/}. Затем создайте файл {@code icon.xml} в каталогах {@code
res/drawable-en-rCA/} и {@code res/drawable-fr-rCA/} который ссылается на ресурс {@code icon_ca.png}
с помощью элемента {@code &lt;bitmap&gt;}. Это позволяет хранить только одну версию файла PNG
и два маленьких файла XML, которые указывают на него. (Пример файла XML показан ниже.)</p>


<h4>Графические объекты</h4>

<p>Чтобы создать псевдоним для существующего графического объекта, используйте элемент {@code &lt;bitmap&gt;}.
Например:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@drawable/icon_ca" />
</pre>

<p>Если сохранить этот файл под именем {@code icon.xml} (в каталоге альтернативных ресурсов, например,
{@code res/drawable-en-rCA/}), он компилируется в ресурс, на который
можно ссылаться с помощью {@code R.drawable.icon}, но фактически он является псевдонимом для ресурса {@code
R.drawable.icon_ca} (который сохранен в каталоге {@code res/drawable/}).</p>


<h4>Макет</h4>

<p>Чтобы создать псевдоним для существующего макета, используйте элемент {@code &lt;include&gt;}
, заключенный в теги {@code &lt;merge&gt;}. Например:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;merge>
    &lt;include layout="@layout/main_ltr"/>
&lt;/merge>
</pre>

<p>Если сохранить этот файл под именем {@code main.xml}, он компилируется в ресурс, на который можно ссылаться
с помощью {@code R.layout.main}, но фактически он является псевдонимом для ресурса {@code R.layout.main_ltr}
.</p>


<h4>Строки и другие простые значения</h4>

<p>Чтобы создать псевдоним для существующей строки используйте идентификатор ресурса нужной
строки в качестве значения для новой строки. Например:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;resources>
    &lt;string name="hello">Hello&lt;/string>
    &lt;string name="hi">@string/hello&lt;/string>
&lt;/resources>
</pre>

<p>Ресурс {@code R.string.hi} теперь является псевдонимом для {@code R.string.hello}.</p>

<p> <a href="{@docRoot}guide/topics/resources/more-resources.html">Другие простые значения</a> работают
аналогично. Например, цвет:</p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;resources>
    &lt;color name="yellow">#f00&lt;/color>
    &lt;color name="highlight">@color/red&lt;/color>
&lt;/resources>
</pre>




<h2 id="Compatibility">Обеспечение оптимальной совместимости устройства с ресурсами</h2>

<p>Для того чтобы приложение поддерживало несколько конфигураций устройств, очень важно
всегда предоставлять ресурсы по умолчанию для каждого типа ресурсов, используемых приложением.</p>

<p>Например, если приложение поддерживает несколько языков, всегда включайте каталог {@code
values/} (в котором сохранены строки) <em>без</em> <a href="#LocaleQualifier">квалификатора языка и региона</a>. Если вместо этого поместить все файлы строк
в каталоги с квалификаторами языка и региона, приложение закроется с ошибкой при запуске
на устройстве, на котором установлен язык, отсутствующий в ваших строках. Но как только вы предоставили ресурсы
{@code values/} по умолчанию, приложение будет работать правильно (даже если пользователь не
понимает этого языка, это лучше, чем завершение с ошибкой).</p>

<p>Таким же образом, если вы предоставляете различные ресурсы макета в зависимости от ориентации экрана, следует
указать одну ориентацию в качестве ориентации по умолчанию. Например, вместо предоставления ресурсов макета в каталоге {@code
layout-land/} для альбомной ориентации и в каталоге {@code layout-port/} для книжной ориентации, оставьте один вариант по умолчанию: например,
{@code layout/} для альбомной и {@code layout-port/} для книжной ориентации.</p>

<p>Предоставление ресурсов по умолчанию важно не только потому, что приложение сможет работать на конфигурации,
которую вы не предусмотрели, но также и потому, что новые версии Android иногда добавляют
квалификаторы конфигураций, которые не поддерживаются более старыми версиями. Если вы используете новый квалификатор ресурсов,
но поддерживаете совместимость кода с более старыми версиями Android, то при выполнении вашего приложения в более старой версии
Android оно завершится в ошибкой, если вы не предусмотрели ресурсы по умолчанию, так как
оно не может использовать ресурсы, проименованные новым квалификатором. Например, если для параметра <a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#min">{@code
minSdkVersion}</a> установлено значение 4 и вы квалифицировали все графические ресурсы с использованием <a href="#NightQualifier">ночного режима</a> ({@code night} или {@code notnight}, который был добавлен в API
уровня 8), то устройства с API уровня 4 не смогут получить доступ к графическим ресурсам и приложение завершится с ошибкой. В этом
случае, вероятно, следует использовать {@code notnight} в качестве ресурсов по умолчанию и исключить этот
квалификатор, разместив графические ресурсы в каталогах {@code drawable/} или {@code drawable-night/}.</p>

<p>Поэтому для обеспечения оптимальной совместимости с устройствами обязательно предоставляйте ресурсы
по умолчанию, которые приложение может правильно выполнять. Затем создайте альтернативные
ресурсы для определенных конфигураций устройств с помощью квалификаторов конфигурации.</p>

<p>Из этого правила есть одно исключение: Если в приложении для параметра <a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#min">{@code minSdkVersion}</a> установлено значение 4 или
выше, <em>не требуется</em> предоставлять графические ресурсы по умолчанию при предоставлении альтернативных графических
ресурсов с квалификатором <a href="#DensityQualifier">плотность экрана</a>. Даже без графических ресурсов
по умолчанию Android может найти наиболее подходящую альтернативную плотность экрана и масштабировать
растровые изображения при необходимости. Однако для оптимальной работы на устройствах всех типов следует
предоставить альтернативные графические ресурсы для всех трех типов плотности.</p>



<h2 id="BestMatch">Как Android находит наиболее подходящий ресурс</h2>

<p>Когда вы запрашиваете ресурс, для которого предоставлена альтернатива, Android выбирает
альтернативный ресурс для использования в режиме выполнения в зависимости от текущей конфигурации устройства. Чтобы
продемонстрировать, как Android выбирает альтернативный ресурс, допустим, что имеются следующие каталоги графических ресурсов,
каждый из которых содержит различные версии одинаковых изображений:</p>

<pre class="classic no-pretty-print">
drawable/
drawable-en/
drawable-fr-rCA/
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</pre>

<p>И допустим, что устройство имеет следующую конфигурацию:</p>

<p style="margin-left:1em;">
Язык = <code>en-GB</code> <br/>
Ориентация экрана = <code>port</code> <br/>
Плотность пикселов на экране = <code>hdpi</code> <br/>
Тип сенсорного экрана = <code>notouch</code> <br/>
Основной способ ввода текста = <code>12key</code>
</p>

<p>Сравнивая конфигурацию устройства с доступными альтернативными ресурсами, Android выбирает
графику из каталога {@code drawable-en-port}.</p>

<p>Система приходит к решению об используемых ресурсах на основе следующей
логики:</p>


<div class="figure" style="width:371px">
<img src="{@docRoot}images/resources/res-selection-flowchart.png" alt="" height="471" />
<p class="img-caption"><strong>Рисунок 2.</strong> Как Android находит наиболее подходящий ресурс.
Структурная схема.</p>
</div>


<ol>
  <li>Исключение файлов ресурсов, которые противоречат конфигурации устройства.
    <p>Каталог <code>drawable-fr-rCA/</code> исключается, так как он
противоречит языку <code>en-GB</code>.</p>
<pre class="classic no-pretty-print">
drawable/
drawable-en/
<strike>drawable-fr-rCA/</strike>
drawable-en-port/
drawable-en-notouch-12key/
drawable-port-ldpi/
drawable-port-notouch-12key/
</pre>
<p class="note"><strong>Исключение.</strong> Квалификатор плотности пикселов на экране не исключается
вследствие противоречия. Хотя плотность экрана устройства hdpi,
каталог <code>drawable-port-ldpi/</code> не исключается, так как на этом этапе любая плотность экрана
считается подходящей. Более подробная информация доступна в документе <a href="{@docRoot}guide/practices/screens_support.html">Поддержка нескольких
экранов</a>.</p></li>

  <li>Указание (следующего) квалификатора с высшим приоритетом в списке (<a href="#table2">таблица 2</a>).
(Начать с MCC, затем двигаться вниз.) </li>
  <li>Содержат ли какие-либо каталоги ресурсов этот квалификатор?  </li>
    <ul>
      <li>Если Нет, вернуться к шагу 2 и найти следующий квалификатор. (В нашем примере
получается ответ «нет», пока не достигнут квалификатор языка.)</li>
      <li>Если Да, перейти к шагу 4.</li>
    </ul>
  </li>

  <li>Исключить каталоги ресурсов, которые не содержат этого квалификатора. В данном примере система исключает
все каталоги, которые не содержат квалификатора языка:</li>
<pre class="classic no-pretty-print">
<strike>drawable/</strike>
drawable-en/
drawable-en-port/
drawable-en-notouch-12key/
<strike>drawable-port-ldpi/</strike>
<strike>drawable-port-notouch-12key/</strike>
</pre>
<p class="note"><strong>Исключение.</strong> Если получен квалификатор плотности пикселов на экране,
Android выбирает вариант, наиболее близко соответствующий плотности экрана устройства.
Как правило, Android предпочитает уменьшать большие исходные изображения, чем увеличивать
мелкие. См. раздел <a href="{@docRoot}guide/practices/screens_support.html">Поддержка нескольких
экранов</a>.</p>
  </li>

  <li>Вернуться и повторять шаги 2, 3 и 4, пока не останется только один каталог. В нашем примере следующим
квалификатором, для которого есть совпадения, является ориентация экрана.
Поэтому исключаются ресурсы, не указывающие ориентацию экрана:
<pre class="classic no-pretty-print">
<strike>drawable-en/</strike>
drawable-en-port/
<strike>drawable-en-notouch-12key/</strike>
</pre>
<p>Остается каталог {@code drawable-en-port}.</p>
  </li>
</ol>

<p>Хотя эта процедура выполняется для каждого запрошенного ресурса, система дополнительно оптимизирует
некоторые вопросы. Одна из таких оптимизаций состоит в том, что поскольку конфигурация устройства известна, можно
исключить альтернативные ресурсы, которые не могут подойти. Например, если используется конфигурация с английским
языком ("en"), все каталоги ресурсов, для которых установлен другой квалификатор языка,
никогда не включаются в пул проверяемых ресурсов (хотя
каталоги ресурсов <em>без</em> квалификатора языка включаются).</p>

<p>При выборе ресурсов на основе квалификаторов размера экрана система будет использовать ресурсы
предназначенные для экрана, меньшего чем текущий экран, если нет более подходящих ресурсов
(например, на экранах большого размера при необходимости будут использоваться ресурсы, предназначенные для экранов нормального размера). Однако, если
 единственные доступные ресурсы <em>превосходят</em> размер текущего экрана, система
<strong>не</strong> будет использовать эти ресурсы, и приложение аварийно завершится, если нет других ресурсов, соответствующих конфигурации
устройства (например, если все ресурсы макета отмечены квалификатором {@code xlarge},
но устройство оснащено экраном нормального размера).</p>

<p class="note"><strong>Примечание.</strong> <em>Приоритет</em> квалификатора (в <a href="#table2">таблице 2</a>) более важен,
чем число квалификаторов, которые точно соответствуют устройству. Например, на шаге 4 выше, последний
вариант в списке содержит три квалификатора, которые точно соответствуют устройству (ориентация, тип
сенсорного экрана и способ ввода), в то время как <code>drawable-en</code> содержит только один подходящий параметр
(язык). Однако язык имеет более высокий приоритет, чем эти остальные квалификаторы, поэтому
<code>drawable-port-notouch-12key</code> вычеркивается.</p>

<p>Для получения более подробной информации об использовании ресурсов в приложении перейдите к разделу <a href="accessing-resources.html">Доступ к ресурсам</a>.</p>
