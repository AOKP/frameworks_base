page.title=Основы создания приложений
@jd:body

<div id="qv-wrapper">
<div id="qv">

<h2>Содержание документа</h2>
<ol>
<li><a href="#Components">Компоненты приложения</a>
  <ol>
    <li><a href="#ActivatingComponents">Активация компонентов</a></li>
  </ol>
</li>
<li><a href="#Manifest">Файл манифеста</a>
  <ol>
    <li><a href="#DeclaringComponents">Объявление компонентов</a></li>
    <li><a href="#DeclaringRequirements">Объявление требований приложения</a></li>
  </ol>
</li>
<li><a href="#Resources">Ресурсы приложения</a></li>
</ol>
</div>
</div>

<p>Приложения для Android пишутся на языке программирования Java. Инструменты Android SDK (Software Development Kit – комплект разработки программного обеспечения) компилируют
написанный вами код &mdash; и все требуемые файлы данных и ресурсов &mdash; в файл APK – <i>программный пакет Android</i>,
который представляет собой файл архива с расширением {@code .apk}. В файле APK находится все, что требуется для работы
Android-приложения, и он позволяет установить приложение на любом устройстве под управлением системы Android.</p>

<p>Каждое приложение Android, установленное на устройстве, работает в собственной "песочнице" (изолированной программной среде): </p>

<ul>
 <li>операционная система Android представляет собой многопользовательскую систему Linux, в которой каждое приложение является
отдельным пользователем;</li>

<li>по умолчанию система назначает каждому приложению уникальный идентификатор пользователя Linux (этот идентификатор используется только
системой и неизвестен приложению); система устанавливает полномочия для всех файлов
 в приложении, с тем чтобы доступ к ним был разрешен только пользователю с идентификатором, назначенным этому приложению; </li>

<li>у каждого процесса имеется собственная виртуальная машина (ВМ), так что код приложения выполняется изолированно от
других приложений;</li>

<li>по умолчанию каждое приложение выполняется в собственном процессе Linux. Android запускает процесс, когда требуется
выполнить какой-либо компонент приложения, а затем завершает процесс, когда он больше не
нужен либо когда системе требуется освободить память для других приложений.</li>
</ul>

<p>Таким образом система Android реализует <em>принцип предоставления минимальных прав</em>. То есть
каждое приложение по умолчанию имеет доступ только к тем компонентам, которые ему необходимы для работы, и
ни к каким другим. Благодаря этому формируется исключительно безопасная среда, в которой приложение не имеет доступа к недозволенным областям
системы.</p>

<p>Однако у приложения есть варианты предоставления своих данных другим приложениям и
доступа к системным службам:</p>

<ul>
  <li>двум приложениям можно назначить один идентификатор пользователя Linux. В этом случае
каждый из них сможет обращаться к файлам другого приложения.  Для экономии ресурсов системы также можно
сделать так, чтобы приложения с одинаковым идентификатором пользователя выполнялись в одном процессе Linux и использовали одну ВМ (
приложения также должны быть подписаны одним сертификатом);</li>
  <li>приложение может запросить разрешение на доступ к данным устройства, например к контактам
пользователя, SMS-сообщениям, подключаемой карте памяти (SD-карте), камере, Bluetooth и др. Все
разрешения должны предоставляться приложению при его установке.</li>
</ul>

<p>Это основные сведения о том, каким образом приложение Android существует в системе. В остальной части
этого документа раскрываются следующие темы:</p>
<ul>
  <li>базовые компоненты, которые определяют приложение;</li>
  <li>файл манифеста, в котором объявляются компоненты и функции устройства, необходимые для
приложения;</li>
  <li>ресурсы, которые существуют отдельно от кода приложения и позволяют приложению
адаптировать свою работу к устройствам с различными конфигурациями.</li>
</ul>



<h2 id="Components">Компоненты приложения</h2>

<p>Компоненты приложения являются кирпичиками, из которых состоит приложение для Android. Каждый
компонент представляет собой отдельную точку, через которую система может войти в приложение. Не все
компоненты являются точками входа для пользователя, а некоторые из них зависят друг от друга. При этом каждый компонент является
самостоятельной структурной единицей и играет определенную роль &mdash; каждый из них представляет собой уникальный элемент структуры, который
определяет работу приложения в целом.</p>

<p>Компоненты приложения можно отнести к одному из четырех типов. Компоненты каждого типа предназначены для определенной цели,
они имеют собственный жизненный цикл, который определяет способ создания и прекращения существования компонента.</p>

<p>Четыре типа компонентов:</p>

<dl>

<dt><b>Операции</b></dt>

<dd>Операция (Activity) <i>представляет</i> собой один экран с пользовательским интерфейсом. Например,
в приложении для работы с электронной почтой одна операция может служить для отображения списка новых
сообщений, другая – для составления сообщения и третья операция – для чтения сообщений. Несмотря на то что
операции совместно формируют связное взаимодействие пользователя с приложением по работе с электронной почтой, каждая из них
не зависит от других операций. Любые из этих операций могут быть запущены
другим приложением (если это позволяет приложение по работе с электронной почтой). Например, приложение для камеры может запустить
операцию в приложении по работе с электронной почтой, которая составляет новое сообщение, чтобы пользователь мог отослать фотографию.

<p>Операция относится к подклассу класса {@link android.app.Activity}. Подробные сведения об этом можно
найти в руководстве для разработчиков в статье <a href="{@docRoot}guide/components/activities.html">Операции</a>
.</p>
</dd>


<dt><b>Службы</b></dt>

<dd>Служба (Service) <i>представляет</i> собой компонент, который работает в фоновом режиме и выполняет длительные
операции, связанные с работой удаленных процессов. Служба
не имеет пользовательского интерфейса. Например, она может воспроизводить музыку в фоновом режиме, пока
пользователь работает в другом приложении, или же она может получать данные по сети, не
блокируя взаимодействие пользователя с операцией. Служба может быть запущена другим компонентом, который затем будут взаимодействовать с ней, – например
операцией.

<p>Служба относится к подклассу класса {@link android.app.Service}. Подробные сведения об этом можно
найти в руководстве для разработчиков в статье <a href="{@docRoot}guide/components/services.html">Службы</a>
.</p>
</dd>


<dt><b>Поставщики контента</b></dt>

<dd>Поставщик <i>контента (Content provider)</i> управляет общим набором данных приложения. Данные можно хранить в
файловой системе, базе данных SQLite, в Интернете или любом другом постоянном месте хранения, к которому у вашего
приложения имеется доступ. Посредством поставщика контента другие приложения могут запрашивать или даже изменять
данные (если поставщик контента позволяет делать это). Например, в системе Android есть поставщик
контента, который управляет информацией контактов пользователя. Любое приложение, получившее соответствующие
разрешения, может запросить часть этого поставщика контента (например {@link
android.provider.ContactsContract.Data}), для чтения и записи сведений об определенном человеке.

<p>Поставщики контента также используются для чтения и записи данных, доступ к которым внешним компонентам
приложение не предоставляет. Например, в образце приложения <a href="{@docRoot}resources/samples/NotePad/index.html">Note Pad</a> с помощью
поставщика контента выполняется сохранение заметок.</p>

<p>Поставщик контента относится к подклассу класса {@link android.content.ContentProvider}.
Он должен реализовывать стандартный набор API-интерфейсов, с помощью которых другие приложения будут выполнять
транзакции. Подробные сведения можно найти в руководстве для разработчиков в статье <a href="{@docRoot}guide/topics/providers/content-providers.html">Поставщики контента</a>
.</p>
</dd>


<dt><b>Приемники широковещательных сообщений</b></dt>

<dd>Приемник широковещательных сообщений (Broadcast receiver) <i>представляет</i> собой компонент, который реагирует на объявления
распространяемые по всей системе.  Многие из этих объявлений рассылает система &mdash; например объявление о том,
что экран выключился, аккумулятор разряжен или был сделан фотоснимок.
Объявления также могут рассылаться приложениями, &mdash; например, чтобы сообщить другим приложениям о том, что
какие-то данные были загружены на устройство и теперь готовы для использования. Несмотря на то что приемники широковещательных сообщений
не имеют пользовательского интерфейса, они могут<a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">создавать уведомления в строке состояния,</a>
чтобы предупредить пользователя о событии "рассылка объявления". Однако чаще всего они являются
просто "шлюзом" для других компонентов и предназначены для выполнения минимального объема работы. Например
, они могут инициировать выполнение службой определенных действий при возникновении события.

<p>Приемник широковещательных сообщений относится к подклассу класса {@link android.content.BroadcastReceiver}
, а каждое такое сообщение предоставляется как объект {@link android.content.Intent}. Подробные сведения изложены
в  руководстве, посвященном классу {@link android.content.BroadcastReceiver}.</p>
</dd>

</dl>



<p>Уникальной особенностью системы Android является то, что любое приложение может запустить компонент
другого приложения. Например, если вы хотите дать пользователю возможность фотографировать, используя
камеру устройства, то, поскольку наверняка имеется другое приложение, которое может выполнить это действие, вместо того чтобы разработать операцию фотографирования в своем приложении, вы можете вызвать
такое приложение. Вам не
нужно внедрять код из приложения для камеры или даже устанавливать на него ссылку.
Вместо этого вы можете просто запустить операцию фотографирования
 из приложения для камеры. По завершении этой операции фотография будет возвращена в ваше приложение, и ее можно будет использовать. Для пользователя
 это будет выглядеть как одно приложение.</p>

<p>Когда система запускает компонент, она запускает процесс для этого приложения (если
он еще не был запущен) и создает экземпляры классов, которые требуются этому компоненту. Например, если ваше приложение
запустит операцию фотографирования в приложении для камеры, эта операция
будет выполняться в процессе, который относится к этому стороннему приложению, а не в процессе вашего приложения.
Поэтому, в отличие от приложений для большинства других систем, в приложениях для Android отсутствует единая
точка входа (например, в них нет функции {@code main()}).</p>

<p>Поскольку система выполняет каждое приложение в отдельном процессе с такими правами доступа к файлам, которые
ограничивают доступ в другие приложения, ваше приложение не может напрямую вызвать компонент из
другого приложения. Это может сделать сама система Android. Поэтому, чтобы вызвать компонент в
другом приложении, необходимо сообщить системе о своем намерении (<em>Intent</em>)
запустить определенный компонент. После этого система активирует для вас этот компонент.</p>


<h3 id="ActivatingComponents">Активация компонентов</h3>

<p>Компоненты трех из четырех возможных типов &mdash; операции, службы и
приемники широковещательных сообщений &mdash; активируются асинхронным сообщением, которое называется <em>Intent</em> (намерение).
Объекты Intent связывают друг с другом отдельные компоненты во время выполнения, будь то это компоненты
 вашего или стороннего приложения (эти объекты Intent можно представить себе
в виде мессенджеров, которые посылают другим компонентам запрос на выполнение действий).</p>

<p>Объект Intent создается с помощью объекта {@link android.content.Intent}, который описывает запрос на
активацию либо конкретного компонента, либо компонента конкретного <em>типа</em> &mdash; соответственно, намерение Intent
может быть явным или неявным.</p>

<p>Для операций и служб Объект Intent определяет действие, которое требуется выполнить (например, просмотреть (view) или
отправить (send) что-то), а также может указывать URI (Uniform Resource Identifier – унифицированный идентификатор ресурса) данных, с которыми это действие нужно выполнить (помимо прочих сведений, которые
нужно знать запускаемому компоненту). Например, объект Intent может передавать запрос
на выполнение операции "показать изображение" или "открыть веб-страницу". В некоторых ситуациях операцию можно
запустить, чтобы получить результат. В этом случае операция возвращает
результат также в виде объекта {@link android.content.Intent} (например, можно отправить сообщение Intent, чтобы дать
пользователю возможность выбрать контакт и вернуть его вам &mdash; в ответном сообщении Intent будет содержаться
URI, указывающий на выбранный контакт).</p>

<p>Для приемников широковещательных сообщений Intent просто определяет
передаваемое объявление (например, широковещательное сообщение о низком уровне заряда аккумулятора
содержит только строку "аккумулятор разряжен").</p>

<p>Компоненты четвертого типа – поставщики контента – сообщениями Intent не активируются. Они
активируются по запросу от {@link android.content.ContentResolver}. Процедура определения
 контента (content resolver) обрабатывает все прямые транзакции с поставщиком контента, с тем чтобы этого не пришлось делать компоненту, который
выполняет транзакции с поставщиком. Вместо этого он вызывает методы для объекта {@link
android.content.ContentResolver}. Это формирует слой, абстрагирующий (в целях безопасности) поставщика
контента от компонента, запрашивающего информацию.</p>

<p>Для активации компонентов каждого типа имеются отдельные методы:</p>
<ul>
  <li>Можно запустить операцию (или определить для нее какое-то новое действие),
передав объект {@link android.content.Intent} методу {@link android.content.Context#startActivity
startActivity()} или {@link android.app.Activity#startActivityForResult startActivityForResult()}
(если требуется, чтобы операция вернула результат).</li>
  <li>Можно запустить службу (либо выдать работающей службе новые инструкции),
передав объект {@link android.content.Intent} методу {@link android.content.Context#startService
startService()}. Либо можно установить привязку к службе, передав объект{@link android.content.Intent} методу
{@link android.content.Context#bindService bindService()}.</li>
  <li>Можно инициировать рассылку сообщений, передав объект {@link android.content.Intent} таким методам, как
{@link android.content.Context#sendBroadcast(Intent) sendBroadcast()}, {@link
android.content.Context#sendOrderedBroadcast(Intent, String) sendOrderedBroadcast()} и {@link
android.content.Context#sendStickyBroadcast sendStickyBroadcast()}.</li>
  <li>Можно выполнить запрос к поставщику контента, вызвав метод {@link
android.content.ContentProvider#query query()} для объекта {@link android.content.ContentResolver}.</li>
</ul>

<p>Подробные сведения об использовании объектов Intent приведены в документе <a href="{@docRoot}guide/components/intents-filters.html">Объекты Intent и
фильтры объектов Intent</a>. Более подробная информация об активации определенных компонентов также приведена
в следующих документах: <a href="{@docRoot}guide/components/activities.html">Операции</a>, <a href="{@docRoot}guide/components/services.html">Службы</a>, {@link
android.content.BroadcastReceiver} и <a href="{@docRoot}guide/topics/providers/content-providers.html">Поставщики контента</a>.</p>


<h2 id="Manifest">Файл манифеста</h2>

<p>Для запуска компонента приложения системе Android необходимо знать, что
компонент существует. Для этого она читает файл {@code AndroidManifest.xml} приложения (файл
манифеста). В этом файле, который должен находиться в корневой папке
приложения, должны быть объявлены все компоненты приложения.</p>

<p>Помимо объявления компонентов приложения, манифест служит и для других целей,
среди которых:</p>
<ul>
  <li>указание всех полномочий пользователя, которые требуются приложению, например разрешения на доступ в Интернет или
на чтение контактов пользователя;</li>
  <li>объявление минимального<a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#ApiLevels">уровня API</a>,
требуемого приложению, с учетом того, какие API-интерфейсы оно использует;</li>
  <li>объявление аппаратных и программных функций, которые нужны приложению или используются им, например камеры,
службы Bluetooth или сенсорного экрана;</li>
  <li>указание библиотек API, с которыми необходимо связать приложение (отличные от API-интерфейсов платформы
Android), например библиотеки <a href="http://code.google.com/android/add-ons/google-apis/maps-overview.html">Google Maps
</a>;</li>
  <li>и многое другое.</li>
</ul>


<h3 id="DeclaringComponents">Объявление компонентов</h3>

<p>Основная задача манифеста – это информировать систему о компонентах приложения. Например,
 файл манифеста может объявлять операцию следующим образом: </p>

<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest ... &gt;
    &lt;application android:icon="@drawable/app_icon.png" ... &gt;
        &lt;activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... &gt;
        &lt;/activity&gt;
        ...
    &lt;/application&gt;
&lt;/manifest&gt;</pre>

<p>Атрибут {@code android:icon} в элементе <code><a
href="{@docRoot}guide/topics/manifest/application-element.html">&lt;application&gt;</a></code>
указывает на ресурсы для значка, который обозначает
приложение.</p>

<p>Атрибут {@code android:name} в элементе <code><a
href="{@docRoot}guide/topics/manifest/activity-element.html">&lt;activity&gt;</a></code>
указывает полное имя класса подкласса {@link
android.app.Activity}, а атрибут {@code android:label} указывает строку,
которую необходимо использовать в качестве метки операции, отображаемой для пользователя.</p>

<p>Все компоненты приложения необходимо объявлять следующим образом:</p>
<ul>
  <li>элементы <code><a
href="{@docRoot}guide/topics/manifest/activity-element.html">&lt;activity&gt;</a></code>
для операций;</li>
  <li>элементы <code><a
href="{@docRoot}guide/topics/manifest/service-element.html">&lt;service&gt;</a></code>
для служб;</li>
  <li>элементы <code><a
href="{@docRoot}guide/topics/manifest/receiver-element.html">&lt;receiver&gt;</a></code>
для приемников широковещательных сообщений;</li>
  <li>элементы <code><a
href="{@docRoot}guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code>
для поставщиков контента</li>
</ul>

<p>Системе не видны операции, службы и поставщики контента, которые имеются в исходном коде, но не объявлены
в манифесте, поэтому они не могут быть запущены.  А вот
приемники широковещательных сообщений
можно либо объявить в манифесте, либо создать динамически в коде (как объекты
{@link android.content.BroadcastReceiver}) и зарегистрировать в системе путем вызова
{@link android.content.Context#registerReceiver registerReceiver()}.</p>

<p>Подробные сведения о структуризации файла манифеста для приложения см. в документе <a href="{@docRoot}guide/topics/manifest/manifest-intro.html">Файл AndroidManifest.xml</a>
. </p>



<h3 id="DeclaringComponentCapabilities">Объявление возможностей компонентов</h3>

<p>Как уже говорилось в разделе <a href="#ActivatingComponents">Активация компонентов</a>, с помощью объекта
{@link android.content.Intent} можно запускать операции, службы и приемники широковещательных сообщений. Для этого в объекте Intent следует
явно указать имя целевого компонента (с помощью имени класса компонента). Однако
в полной мере возможности объектов Intent раскрываются при использовании концепции <em>неявных Intent</em>. В неявном сообщении Intent
просто описывается тип действия, которое требуется выполнить (а также, хотя это и не обязательно, дата, в которую вы бы хотели
выполнить это действие). Системе же предоставляется возможности найти на устройстве компонент, который может выполнить это
действие, и запустить его. При наличии нескольких компонентов, которые могут выполнить действие, описанное в сообщении
Intent, пользователь выбирает, какой из них будет использоваться.</p>

<p>Система определяет компоненты, которые могут ответить на сообщение Intent, путем сравнения
полученного сообщения Intent с <i>фильтрами объектов Intent,</i> указанными в файле манифеста других приложений, имеющихся
 на устройстве.</p>

<p>При объявлении операции в манифесте своего приложения по желанию можно указать
фильтры объектов Intent, которые указывают возможности операции, с тем чтобы она могла реагировать на сообщения Intent
от других приложений. Чтобы объявить фильтр Intent для своего компонента,
необходимо добавить элемент <a href="{@docRoot}guide/topics/manifest/intent-filter-element.html">{@code
&lt;intent-filter&gt;}</a> в качестве дочернего для элемента объявления компонента.</p>

<p>Например, если вы создали приложение для работы с электронной почтой с операцией составления нового сообщения, вы можете
объявить фильтр для ответа на сообщения Intent типа "send" (для отправки нового сообщения электронной почты) следующим образом:</p>
<pre>
&lt;manifest ... >
    ...
    &lt;application ... &gt;
        &lt;activity android:name="com.example.project.ComposeEmailActivity">
            &lt;intent-filter>
                &lt;action android:name="android.intent.action.SEND" />
                &lt;data android:type="*/*" />
                &lt;category android:name="android.intent.category.DEFAULT" />
            &lt;/intent-filter>
        &lt;/activity>
    &lt;/application&gt;
&lt;/manifest>
</pre>

<p>Затем, если другое приложение создаст объект Intent с действием {@link
android.content.Intent#ACTION_SEND} и передаст его в {@link android.app.Activity#startActivity
startActivity()}, система сможет запустить вашу операцию, дав пользователю возможность написать и отправить
сообщение электронной почты.</p>

<p>Подробные сведения о создании фильтров объектов Intent приведены в документе <a href="{@docRoot}guide/components/intents-filters.html">Объекты Intent и фильтры объектов Intent</a>.
</p>



<h3 id="DeclaringRequirements">Объявление требований приложения</h3>

<p>Существует огромное количество устройств, работающих под управлением Android, и не все они имеют
одинаковые функциональные возможности. Чтобы ваше приложение не могло быть установлено на устройствах,
в которых отсутствуют функции, необходимые приложению, важно четко определить профиль для
типов устройств, поддерживаемых вашим приложением, указав требования к аппаратному и программному обеспечению в
файле манифеста. Эти объявления по большей части носят информационный характер, система их не
читает. Однако их читают внешние службы, например Google Play, с целью обеспечения
фильтрации для пользователей, которые ищут приложения для своих устройств.</p>

<p>Например, если вашему приложению требуется камера и оно использует API-интерфейсы из Android 2.1 (<a href="{@docRoot}guide/topics/manifest/uses-sdk-element.html#ApiLevels">уровень API</a> 7),
эти параметры следует объявить в файле манифеста в качестве требований следующим образом:</p>

<pre>
&lt;manifest ... >
    &lt;uses-feature android:name="android.hardware.camera.any"
                  android:required="true" />
    &lt;uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
    ...
&lt;/manifest>
</pre>

<p>Теперь ваше приложение нельзя будет установить из Google Play на устройствах, в которых <em>нет</em> камеры, а также на устройствах, работающих под управлением
Android версии <em>ниже</em> 2.1.</p>

<p>Однако можно также объявить, что приложение использует камеру, но для его работы она не является
<em>непременно необходимой</em>. В этом случае в приложении атрибуту <a href="{@docRoot}guide/topics/manifest/uses-feature-element.html#required">{@code required}</a>
необходимо задать значение {@code "false"}, а во время работы оно должно проверять, имеется ли
на устройстве камера, и при необходимости отключать свои функции, которые используют камеру.</p>

<p>Более подробные сведения об управлении совместимостью своего приложения с различными устройствами
приведены в документе <a href="{@docRoot}guide/practices/compatibility.html">Совместимость устройств</a>
.</p>



<h2 id="Resources">Ресурсы приложения</h2>

<p>Приложение Android состоит не только из кода &mdash; ему необходимы такие существующие отдельно от исходного кода
ресурсы, как изображения, аудиофайлы и все, что связано с визуальным
представлением приложения. Например, необходимо определять анимацию, меню, стили, цвета
и макет пользовательских интерфейсов операций в файлах XML. Используя ресурсы приложения, можно без труда
изменять его различные характеристики, не меняя код, а, кроме того, &mdash;путем предоставления
наборов альтернативных ресурсов &mdash; можно оптимизировать свое приложение для работы с различными
конфигурациями устройств (например, для различных языков или размеров экрана).</p>

<p>Для каждого ресурса, включаемого в проект Android, инструменты SDK задают уникальный
целочисленный идентификатор, который может использоваться, чтобы сослаться на ресурс из кода приложения или из
других ресурсов, определенных в XML. Например, если в вашем приложении имеется файл изображения с именем {@code
logo.png} (сохраненный в папке {@code res/drawable/}), инструменты SDK сформируют идентификатор ресурса
под именем {@code R.drawable.logo}, с помощью которого на изображение можно будет ссылаться и вставлять его в
пользовательский интерфейс.</p>

<p>Один из наиболее важных аспектов предоставления ресурсов отдельно от исходного кода
заключается в возможности использовать альтернативные ресурсы для различных конфигураций
устройств. Например, определив строки пользовательского интерфейса в XML, вы сможете перевести их на другие
языки и сохранить эти переводы в отдельных файлах. Затем по <em>квалификатору</em> языка
, добавленному к имени каталога ресурса (скажем {@code res/values-fr/} для строк на французском
языке), и выбранному пользователем языку система Android применит к вашему пользовательскому интерфейсу строки на
соответствующем языке.</p>

<p>Android поддерживает разные <em>квалификаторы</em> для соответствующих ресурсов. Квалификатор
 представляет собой короткую строку, которая включается в имена каталогов ресурсов с целью
определения конфигурации устройства, для которой эти ресурсы следует использовать. В качестве другого
примера можно сказать, что для своих операций следует создавать разные макеты, которые будут соответствовать
размеру и ориентации экрана устройства. Например, когда экран устройства имеет книжную
ориентацию (расположен вертикально), кнопки в макете можно также размещатьь по вертикали, а когда экран
развернут горизонтально (альбомная ориентация), кнопки следует размещать по горизонтали. Чтобы при изменении ориентации экрана изменялся макет,
можно определить два разных макета и применить соответствующий
квалификатор к имени каталога каждого макета. После этого система будет автоматически применять соответствующий
макет в зависимости от ориентации устройства.</p>

<p>Подробные сведения о различных видах ресурсов, которые можно включить в приложение, а также о том, как
создавать альтернативные ресурсы для разных конфигурацией устройств, см. в разделе <a href="{@docRoot}guide/topics/resources/providing-resources.html">Предоставление ресурсов</a>.</p>



<div class="next-docs">
<div class="col-6">
  <h2 class="norule">Также читайте:</h2>
  <dl>
    <dt><a href="{@docRoot}guide/components/intents-filters.html">Объекты Intent и фильтры объектов Intent</a>
    </dt>
    <dd>Сведения об использовании API-интерфейсов {@link android.content.Intent} для
    активации таких компонентов приложений, как операции и службы, а также о предоставлении возможности другим приложениям
    использовать компоненты своего приложения.</dd>
    <dt><a href="{@docRoot}guide/components/activities.html">Операции</a></dt>
    <dd>Сведения о создании экземпляра класса {@link android.app.Activity},
 который выдает определенный экран в вашем приложении с пользовательским интерфейсом.</dd>
    <dt><a href="{@docRoot}guide/topics/resources/providing-resources.html">Предоставление ресурсов</a></dt>
    <dd>Описание структуры приложений Android, в которой ресурсы приложения существуют отдельно от
   его кода, а также сведения о том, как предоставлять альтернативные ресурсы для определенных конфигураций
   устройств.
    </dd>
  </dl>
</div>
<div class="col-6">
  <h2 class="norule">Возможно, вас также заинтересует:</h2>
  <dl>
    <dt><a href="{@docRoot}guide/practices/compatibility.html">Совместимость устройств</a></dt>
    <dd>Сведения о том, каким образом система Android работает на устройствах разных типов, и общие сведения о том,
    как оптимизировать свое приложение для каждого устройства или ограничить круг устройств, на которых может быть установлено
    приложение.</dd>
    <dt><a href="{@docRoot}guide/topics/security/permissions.html">Системные разрешения</a></dt>
    <dd>Сведения о том, как система Android ограничивает доступ приложений к определенным API-интерфейсам с помощью системы
    разрешений, которая требует согласия пользователя на использование этих API-интерфейсов вашим приложением.</dd>
  </dl>
</div>
</div>

